# Курс по Java. Part 2 #
## ООП ##

В Java никакой класс не должен лежать в root-директории src. Нужно создавать пакеты.

Live-template - пишем ключевое слово и нажимаем Tab (или Enter). Idea сама генерирует нужный код.
Ex. iter - цикл for-each. main, sout e.t.c

Структурное программирование - последовательное выполнение кода, строчка за строчкой.

ООП - стиль программирования, в котором операции производятся над объектами, используется их функционал и изменяется их состояние.

Объект - конкретный экземпляр кого-либо класса.

Классы согласно конвенции именуются с большой буквы в camel-case, методы с маленькой буквы. Исключение - конструктор, его имя должно совпадать с именем класса и начинаться с большой буквы.

Ctrl + D - продублировать выделенный код.

В сигнатуру метода входит название функции и аргументы. Возвращаемый тип не входит в сигнатуру метода, он не учитывается при перегрузке.

Ctrl + P - показывает все возможные перегрузки метода.

Модификаторы доступа ставятся над классами, полями, методами.

package private (нет модификатора) - доступ только внутри пакета.

protected - похож на package-private, только ещё доступ предоставляется в классах-наследниках.

Для классов, кроме внутренних вложенных можно указывать либо public, либо ничего.

Пакет - неотъемлимая часть имени класса.

Пакет java.lang импортится автоматически.

## Heap and Stack

При начале работы Java-приложения ему выделяется некоторое колличество оперативной памяти, необходимой для работы. Размер памяти определяется через параметры командной строки или дефолтным значением.

Память, которая выделяется под Java-процесс разбивается на два блока: самый большой - Heap и Stack.

Heap - общий для всех потоков, а Stack создаётся для каждого потока свой.

В многопоточности возникают коллизии, когда из разных Stackов происходит доступ к одному и тому же объекту в Heap.

Правила:
1. Во время выполнение программ все локальные переменные примитивного типа (и их значения) полностью находятся в стековой области памяти. 
2. Ключевое слово new означает выделение памяти под объект в Heap. В Stack хранится ссылка на эту область памяти.

В Java по умолчанию под ссылки выделяется 4 байта. Размер зависит от размера Heap, если он больше 32 ГБ, то на ссылку выделяется 8 байт, чтобы покрыть адресное пространство.

У каждого объекта есть ссылка this, которая указывает на этот объект, для удобства.

После выполнения потока все ссылки на объекты в Heap удаляются. И необходимо собрать мусор с помощью Garbage Collector. В Heap есть разные области памяти, чтобы разделять новые и старые объекты и запускать разные механизмы для очистки Heap.

Ctrl + Alt + M - участок кода переносится в отдельный метод.

По статистике строки занимают до 70% объема Heap, поэтому придуманы различные методы обратки строк. 
Например, кэширование, то есть, если строка есть в Heap, её переиспользуют, а не создают объект заново.

Модификатор static указывает, что поле или метод относится ко всему классу, а не к конкретному экземпляру и может быть вызван по имени класса.
Вызвать через ключевое слово this значение этого поля нельзя.

Метод getClass возвращает класс, к которому принадлежит объект.
Class<? extends Computer> clazz = computer.getClass();

класс Class необходим, чтобы инициализировать классы, которые мы создаём. На каждый класс, который мы создали создаётся объект, который сохраняется в MetaSpace - область памяти в Heap для хранения классов.

Static используется для утилитных классов, для которых не нужен конретный экземпляр.

Константы в классах принято создавать статическими.

prsf - создание private static final.

Согласно конвенции все константы должны именоваться в upper-case и snake-case.

## Класс String

В классе String главное поле - byte[] value. В более ранних версиях было char[]. Замена связана с более оптимальным использованием памяти, большинство строк представляют собой массивы латинских символов, один символ занимает 1 байт, а char занимает 2 байта.

По умолчанию Charset - utf-8. Можно передавать Charset в конструктор String.

Строки сравниваются методом compareTo.

lines() - возвращает стрим из строки.

Из static функции мы можем вызывать только static функции, либо статеческие методы у классов.

Ctrl + Alt + V - создание переменной.

Ctrl + Alt + N - убрать локальную переменную (inline).

Все методы класса String создают новую строку, так как объекты класса String immutable.

System - утилитный метод. Содержит только private конструктор, т.е. экземпляр этого класса можно создать только из него самого.

Для конкатенации строк в цикле необходимо использовать StringBuilder. При обычной конкатенации строк каждый раз создаётся новый объект.
В классе StringBuilder так же есть массив char[] value, но ещё и счётчик count, который показывает на сколько заполнен массив.
StringBuilder работает похожим образом на ArrayList. Таким образом новый объект создаётся тольк тогда когда заканчивается capacity массива value.

StringBuffer - потокобезопасный класс, то есть все его методы синхронизированы (помечены ключевым словом synchronized - то есть эту функцию у одного и того же объекта может вызвать только один поток одновременно)

Однако часто используется и StringBuilder т.к. мы создаём локальную переменную этого типа, которая потокобезопасна. Потому что каждый поток создаёт свою локальную переменную и только у него есть доступ к ссылке на эту переменную.

## Принципы ООП

Инкупсуляция - скрытие сложности(поля) от пользователя.
public-методы называют интерфейсами.

extends - ключевое слово наследования. При наследовании мы обязаны вызвать в конструкторе, один из конструкторов родителя (super()).
super() вызывается в первой строчке.
Если в классе есть конструктор без параметров, то super() можно опустить.

В Java нет множественного наследования.

В Java все классы наследуются от класса Object.

Ctrl + F12 - отображение всех методов класса.

Через ключевое слово this() можно вызвать конструктор данного класса.

native - ключевое слово, означающее, что данный метод использует нативные библиотеки (напианные на С, С++) для улучшения производительности.

В каждом классе можно указать блок инициализации (используется редко), он выполняется перед конструктором:
 {
    System.out.println("init")
 }

Статический блок инициализации вызывется один раз при создании первого объекта класса, т.е. когда создаётся объект класса Class
 static {
    System.out.println("init")
 }


## Абстрактные классы

+ Запрещается создавать экземпляры класса.
+ Класс создан только для его наследования.

Чтобы сделать класс абстрактным его нужно пометить ключевым словом abstract.

Абстрактный метод - метод, который должен быть переопределен во всех классах наследниках.

Ex. public abstract void load();

Если другой абстрактный класс наследует абстрактный, то нет обязательства реализовывать абстрактный метод.

Мы не можем создать абстрактный метод у неабстрактного класса.

Чтобы запретить наследование от данного класса нужно использовать ключевое слово final. Нельзя одновременно ипользовать ключевые слова final и abstract.

Полиморфизм - один интерфейс и множество реализаций.
Под интерфейсом понимается открытый функционал класса.

Переопределить можно не только абстрактные методы, главное, чтобы они не были private.

Мы не можем сужать область видимости базового функционала.

instanseof - действительно ли ссылка ведёт на объект указанного типа.

Если пометить метод ключевым словом final его нельзя будет переопределить в классах-наследниках.

static методы нельзя переопределить, потому что они относятся не к объекту, а к классу.

Интерфейсы нужны для того, чтобы привнести какой-то функционал в наш класс.
В интерфейсах в отличии от абстрактных классов нельзя создавать никакие поля, кроме констант.
В интерфейсах все методы по умолчанию public abstract.
Интерфейсы так же можно наследовать ключевым словом extends, только в отличии от классов допустимо множественное наследование т.к. это наследование интерфейсов.

Ключевое слово default введно начиная с Java 8. В Java 8 появились stream в коллекциях и было необходимо привнести новый функционал в существующую иерархию коллекций, но без её расширения и введения новых классов. Дефолтные методы не зависят от состояния, а зависят от функционала.

Так же в Java 8 стало возможным создавать private методы в интерфейсах. Такие методы можно было бы создавать static, но тогда к ним будет доступ и вне, а так как это скрытая реализация из сделали private.

Во вложенных классах помимо модификаторов public и package private допустимо использовать private.

Вложенные классы могут быть static, но тогда у них теряется доступ к методам внешнего класса, к полям, доступ остаётся.

Локальный класс описывается и объявляется внутри метода.

Enum - нужен когда необходимо ограничить число наследников класса.
Константы в enum пишутся в Snake Upper case, по сути это обычные классы.
Доступны методы values(), ordinal() и так далее.
Java автоматически создает singltone констант в enum.
Нельзя наследоваться или наследовать enum.
Но доступна реализация интерфейсов (в том числе абстрактных). Переопределение абстрактных методов происходит прямо в блоке кода после каждого из перечислений. Так же можно и переопределить методы интерфейса либо для каждого класса, либо для всего enum в отдельном методе.

## Generics

Generics - обобщенные типы.

В Java запрещено создавать массивы параметризованного типа, т.к. неизвестно, сколько выделить под него памяти.

При объявлении класса, даже если он параметризован, Java допускает не указвать тип класса для совместимости с предыдущими версиями. При этом класс параметризуется типом Object.

Generics нужны для безопасной работы с типами объектов.

Есть два уровня параметризации - на уровне класса и на уровне метода.

public abstract class Hero\<T> {...}

public class Archer\<T> extends Hero\<T> {...}

Параметризацию так же можно ограничивать: 

public interface Weapon {...}<br>
public interface RangeWeapon extends Weapon {...}<br>
public class Bow inplements RangeWeapon {...}

public abstract class Hero\<T extends Weapon> {...}

public class Archer\<T extends RangeWeapon> extends Hero\<T> {...}
Archer\<Bow> archer = new Archer<>();

каждый класс может быть параметризован несколькими типами

Параметризация на уровне метода:
public static \<T extends Weapon> void printWeaponDamage(Hero\<T> hero) {...}

Можно использовать wildcard:
public static void printWeaponDamage(Hero\<? extends Weapon> hero) {...}

Можно ограничивать наследование снизу т.е. для всех предшественников:
public static void printWeaponDamage(Hero\<? super Weapon> hero) {...}

Ограничения сверху и снизу используются для 
* Producer - extends
* Consumer - super



























